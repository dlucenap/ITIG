\chapter{Análisis destallado del Código}

\section{Tableros de Pruebas}

\subsection{Tablero 1}
\paragraph{Propósito:} Se trata del tablero de prueba utilizado para
confeccionar el juego. Es un tablero ideal para conformar algoritmos para
resolución simple y por métodos de "backtraking" sobre el tablero.
\paragraph{Prototipo:}
\paragraph{Tablero:} 
\begin{verbatim}
let tablero1 =
".2..06.74....7..3.1.02..81....5.9.........A.342.4.2.1..3......A36.2..........8.
129......4..0.A.6.0B1.3.........4.0....8A..10.5.8..9....89.3A..0.";;
\end{verbatim}

\subsection{Tablero 2}
\paragraph{Propósito:} Se trata de un tablero correcto para pruebas sobre
resolución del mismo añadiendo o eliminando jugadas.
\paragraph{Prototipo:}
\paragraph{Tablero:}
\begin{verbatim}
let tablero2 =
"6193B07A24850AB43528967175281694A03B8B47610235A99610A45382B7235A78B96104B4390A6
517281765928B034AA80243175B9649A15730B862508B29467A1332768BA14950";;
\end{verbatim}

\subsection{Tablero 3}
\paragraph{Propósito:} Se trata de un tablero correcto para pruebas sobre
resolución del mismo añadiendo o eliminando jugadas.
\paragraph{Prototipo:}
\paragraph{Tablero:}
\begin{verbatim}
let tablero3 =
"6193.07A24850AB43528967175281694A03B8B47610235A99610A45382B7235A78B96104B4390A6
517281765928B034AA80243175B9649A15730B862508B29467A1332768BA14950";;
\end{verbatim}

\subsection{Tablero 4}
\paragraph{Propósito:}
\paragraph{Prototipo:}
\paragraph{Tablero:} 
\begin{verbatim}
let tablero4 =
"............BA98765432.........................................................
.................................................................";;
\end{verbatim}

\section{Lógica para Imprimir Tablero}

\subsection{cadenahaciaListadeChar}

\paragraph{Propósito:} Convierte una cadena de "String" hacia una lista de Char.
\paragraph{Prototipo:} cadenahaciaListadeChar : string -> char list = <fun>
\paragraph{Prueba 1:} let lstTablero tablero = cadenahaciaListadeChar tablero;;
\paragraph{Código:}
\begin{verbatim}
let rec cadenahaciaListadeChar = function str -> let long = string\_length str
in if long = 0 then []                                                                        
else (nth\_char str 0) :: cadenahaciaListadeChar(sub\_string str 1 (long-1));;
\end{verbatim}

\subsection{lstTablero}

\paragraph{Propósito:}
\paragraph{Prototipo:}
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let lstTablero tablero = cadenahaciaListadeChar tablero;;
\end{verbatim}

\subsection{imprimeTerciodeLinea}

\paragraph{Propósito:} Imprime cuatro casillas sobre el todal de doce de una línea de
tablero.
\paragraph{Prototipo:} imprimeTerciodeLinea : char list * int -> char list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec imprimeTerciodeLinea (linea,indice) = if (indice < 5 ) then 
			 begin
			 print\_string " ";  
			 print\_char (hd linea);
			 print\_string " "; 	                 
			 imprimeTerciodeLinea ((tl linea),indice+1)
			 end
			                       else linea;;
\end{verbatim}

\subsection{imprimeLinea}

\paragraph{Propósito:} Imprime una línea del tablero.
\paragraph{Prototipo:} imprimeLinea : char list * int -> char list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec imprimeLinea (linea,indice) = if (indice < 4 ) then 
			begin
			print\_string " /";
			imprimeLinea((imprimeTerciodeLinea (linea,1)), indice+1)
			end 
			              else 
				         begin
                                            print\_string "/";
                                            print\_newline();
					    linea
				         end;;
\end{verbatim}

\subsection{imprimeCuartodeTablero}

\paragraph{Propósito:} Imprime tres líneas de tablero. 1/4 del total de casillas.
\paragraph{Prototipo:} imprimeCuartodeTablero : char list * int -> char list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec imprimeCuartodeTablero (linea,indice) = if (indice < 37 ) then 
imprimeCuartodeTablero((imprimeLinea (linea,1)), indice+12)
		else 
		begin
		print\_string "------------------------------------------";
		print\_newline();
		linea
		end;;
\end{verbatim}

\subsection{imprimeContenidodeTablero}

\paragraph{Propósito:} Imprime las casillas del tablero. 
\paragraph{Prototipo:} imprimeContenidodeTablero : char list * int -> unit = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec imprimeContenidodeTablero (linea,indice) = if (indice < 5 ) then 	                      
imprimeContenidodeTablero((imprimeCuartodeTablero(linea,1)), indice+1)
					           else 
						      ();;
\end{verbatim}

\subsection{imprimirTablero}

\paragraph{Propósito:} Imprime el tablero completo. Es el "front end" de
"imprimeContenidodeTablero".
\paragraph{Prototipo:} imprimirTablero : char list -> unit = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let imprimirTablero tablero = begin
	print\_newline();
	print\_string "------------------------------------------";
	print\_newline();
	imprimeContenidodeTablero (tablero,1);
	()
	end;;
\end{verbatim}

\subsection{mostrarTablero}

\paragraph{Propósito:} Muestra el tablero sobre una cadena que convierte a lista de "Char". 
\paragraph{Prototipo:} mostrarTablero : string -> unit = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let mostrarTablero tablero = begin
        let lstTablero = cadenahaciaListadeChar tablero in 
	imprimirTablero lstTablero;
	()
	end;;
\end{verbatim}

\section{Lógica para Tratar Jugada}

\subsection{valordeAccion}

\paragraph{Propósito:} Traduce la numeración "Int" a valor sobre tablero, "String". Por
ejemplo, si el jugador introduce como jugada el valor 20 se traduce como ficha
"A".
\paragraph{Prototipo:} valordeAccion : int -> string = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let valordeAccion accion = if(accion = 10 ) then "0" 
		           else if (accion = 11) then "1" 
			   else if (accion = 12) then "2"
			   else if (accion = 13) then "3" 
			   else if (accion = 14) then "4" 
			   else if (accion = 15) then "5" 
			   else if (accion = 16) then "6" 
			   else if (accion = 17) then "7" 
                           else if (accion = 18) then "8" 
			   else if (accion = 19) then "9" 
                           else if (accion = 20) then "A" 
			   else if (accion = 21) then "B" 
			   else "999";;

\end{verbatim}

\subsection{substrPreAccion}

\paragraph{Propósito:} Crea una cadena desde el valor 0 de str hasta el valor "-1" sobre el
que se cambia la ficha.
\paragraph{Prototipo:} substrPreAccion : string * int * int -> string = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let substrPreAccion (str, linea, columna) =  sub\_string str 0 
((12*((linea)-1)+(columna))-1);;
\end{verbatim}

\subsection{substrPostAccion}

\paragraph{Propósito:} Crea una cadena desde el valor "acción+1" de str hasta el valor
límite de str.
\paragraph{Prototipo:} substrPostAccion : string * int * int -> string = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let substrPostAccion (str, linea, columna) = let salida =
((12*((linea)-1)+(columna))) in sub\_string str salida ((string\_length
str)-salida);;
\end{verbatim}

\subsection{jugada}

\paragraph{Propósito:} Comprueba si el valor de jugada es correcto y porteriormente inserta
la jugada y reconstruye el tablero.
\paragraph{Prototipo:} jugada : string * int * int * int -> string = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec jugada (str, linea, columna, accion) = begin
                if (accion > 21) then begin 
                  print\_string "Las jugada es incorrecta..."; 
                  jugada(str, linea, columna, accion);
                  ""
                  end
                else concat [(substrPreAccion
(str, linea, columna));(valordeAccion accion);(substrPostAccion (str, linea,
columna))]
                                               end;;
\end{verbatim}

\subsection{introDatos}

\paragraph{Propósito:} Pide los datos necesarios para la jugada y comprueba si esta en el
rango correcto.
\paragraph{Prototipo:} introDatos : string * int * int -> int = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec introDatos (tipo, min, max) = begin
                   print\_string "Por favor introduzca ";
		   print\_string tipo;
		   print\_string " de (";
		   print\_int min;
		   print\_string " a ";
		   print\_int max;
		   print\_string "): ";
                   let aux = read\_int () in
                      if(aux >= min) \&\& (aux <= max) then aux
		      else introDatos (tipo, min, max)
				       end;;
\end{verbatim}

\subsection{introJugada}

\paragraph{Propósito:} Llama a "introDatos" con jugada y rangos. Es el "font end" de
"introDatos".
\paragraph{Prototipo:} introJugada : string * int * int * int * int -> string = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec introJugada(tablero, fila, columna, juego, opcion) = if(opcion = 1)
then begin
   let aux = introDatos("Fila", 1, 12) in 
   introJugada(tablero, aux, 0, 0, 2)
      end
else if (opcion = 2) then begin
   let aux = introDatos("Columna", 1, 12) in 
   introJugada(tablero, fila, aux, 0, 3)
      end
else if (opcion = 3) then begin
   let aux = introDatos("Jugada", 10, 21) in 
   introJugada(tablero, fila, columna, aux, 4)
      end
else if (opcion = 4) then
   jugada(tablero, fila, columna, juego)
else "";;
\end{verbatim}

\section{Lógica para determinar su el Tablero es Correcto}

\subsection{fila}

\paragraph{Propósito:} Funcion que devuelve la fila para una determinada posicion 'p' del
tablero.
\paragraph{Prototipo:} fila : int -> int = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let fila p = if p mod 12 = 0 then (p / 12) 
             else 
	        (p / 12)+1;;
\end{verbatim}

\subsection{columna}

\paragraph{Propósito:} Funcion que devuelve la columna para una determinada posicion 'p' del
tablero.
\paragraph{Prototipo:} columna : int -> int = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let columna p = if p mod 12 = 0 then 12 
	        else 
	           p mod 12;;
\end{verbatim}

\subsection{listaFila}

\paragraph{Propósito:} Función que devuelve la lista con los índices que forman la fila en
la que está situada la casilla que se pasa como parámetro.
\paragraph{Prototipo:} listaFila : int -> int list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let listaFila = function p -> let n = (fila p)-1 in
[1+n*12;2+n*12;3+n*12;4+n*12;5+n*12;6+n*12;7+n*12;8+n*12;9+n*12;10+n*12;11+n*12;
12+n*12];;
\end{verbatim}

\subsection{listaColumna}

\paragraph{Propósito:} Función que devuelve la lista con los índices que forman la columna
en la que está situada una determinada casilla.
\paragraph{Prototipo:} listaColumna : int -> int list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let listaColumna = function p -> let n = columna p in
[n;n+12;n+24;n+36;n+48;n+60;n+72;n+84;n+96;n+108;n+120;n+132];;
\end{verbatim}

\subsection{cuadrado}

\paragraph{Propósito:} Función para obtener el cuadrado en el que se encuentra una posición.
\paragraph{Prototipo:} cuadrado : int -> int = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let cuadrado p = if (p > 0) \& ((fila p)-1)/3 = 0 then 
		                               (((columna p)-1)/4) + 1 
  		 else if ((fila p)-1)/3 = 1 then 
			                       (((columna p)-1)/4) + 4 
  		 else if ((fila p)-1)/3 = 2 then 
		                               (((columna p)-1)/4) + 7
  		 else if ((fila p)-1)/3 = 3 then 
		                               (((columna p)-1)/4) + 10  
  	         else
	            failwith "La posicion no se encuentra en el tablero...";;
\end{verbatim}

\subsection{listaCuadrado}

\paragraph{Propósito:} Función que devuelve una lista con los índices del cuadrado al que
pertenece un cierto elemento.
\paragraph{Prototipo:} listaCuadrado : int -> int list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let listaCuadrado p = let n = cuadrado p in [1+36*((n-1)/3)+4*((n-1) mod 3);
					    2+36*((n-1)/3)+4*((n-1) mod 3);
					    3+36*((n-1)/3)+4*((n-1) mod 3);
					    4+36*((n-1)/3)+4*((n-1) mod 3);
					    3+36*((n-1)/3)+4*((n-1) mod 3);
					    14+36*((n-1)/3)+4*((n-1) mod 3);
					    15+36*((n-1)/3)+4*((n-1) mod 3);
					    16+36*((n-1)/3)+4*((n-1) mod 3);
					    25+36*((n-1)/3)+4*((n-1) mod 3);
					    26+36*((n-1)/3)+4*((n-1) mod 3);
					    27+36*((n-1)/3)+4*((n-1) mod 3);
					    28+36*((n-1)/3)+4*((n-1) mod 3)];;
\end{verbatim}

\subsection{elemento}

\paragraph{Propósito:} Función que devuelve un elemento a partir de una lista de elementos
dada y su posición.
\paragraph{Prototipo:} elemento : int * int * 'a list -> 'a = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec elemento (indice,recorrido,tabla) = if(indice = recorrido) then hd tabla
				            else elemento (indice,(recorrido+1), tl tabla);;
\end{verbatim}

\subsection{buscarElemento}

\paragraph{Propósito:} Se trata de un "front" de "elemento", con algunas particularidades.
En el caso de encontrar agua devuelve el valor uno sino devuelve el indice del
recorrido, e igualmente comprueba que los elementos no se repitan.
\paragraph{Prototipo:} buscarElemento : char * char list * int -> int list -> int = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec buscarElemento (elementoIndice,tablero,contador) = function [] -> contador
		 |h::f -> if(elementoIndice = `.`) then 1
			  else if(elemento(h,1,tablero) = elementoIndice) then buscarElemento
(elementoIndice,tablero,(contador+1)) f
			  else buscarElemento (elementoIndice,tablero,contador) f;;
\end{verbatim}

\subsection{}

\paragraph{Propósito:} Función que usa "buscarElemento" para dado un índce de reccorrido 1 y
contador 0 comprobar la condición de que no existe agua y todos los elementos de
cada fila son distintos. 
\paragraph{Prototipo:} sonlasFilaCorrectas : int * char list -> bool = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec sonlasFilaCorrectas (indice,tablero) = if indice > 144 then true
					       else if (buscarElemento
(elemento(indice,1,tablero),tablero,0) (listaFila indice)) > 1 then false 
					       else sonlasFilaCorrectas
				       ((indice+1),tablero);;
\end{verbatim}

\subsection{sonlasColumnasCorrectas}

\paragraph{Propósito:} Función que usa "buscarElemento" para dado un índce de reccorrido 1 y
contador 0 comprobar la condición de que no existe agua y todos los elementos de
cada columna son distintos. 
\paragraph{Prototipo:} sonlasColumnasCorrectas : int * char list -> bool = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec sonlasColumnasCorrectas (indice,tablero) = if indice > 144 then true
					           else if (buscarElemento
(elemento(indice,1,tablero),tablero,0) (listaColumna indice)) > 1 then false 
					           else sonlasColumnasCorrectas
                                       ((indice+1),tablero);;
\end{verbatim}

\subsection{sonlosCuadradosCorrectos}

\paragraph{Propósito:} Función que usa "buscarElemento" para dado un índce de reccorrido 1 y
contador 0 comprobar la condición de que no existe agua y todos los elementos de
cada cuadrado son distintos. 
\paragraph{Prototipo:} sonlosCuadradosCorrectos : int * char list -> bool = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let rec sonlosCuadradosCorrectos (indice,tablero) = if indice > 144 then true
					            else if (buscarElemento
(elemento(indice,1,tablero),tablero,0) (listaCuadrado indice)) > 1 then false 
					            else
				sonlosCuadradosCorrectos ((indice+1),tablero);;
\end{verbatim}

\subsection{esSudokuCorrecto}

\paragraph{Propósito:}Es el "front" para las tres funciones anteriores. Devuelve "true" o
"false" sobre si el tablero cumple la condición de que no existen elementos
repetidos en: cada fila, cada columna y cada cuarto de tablero. 
\paragraph{Prototipo:} esSudokuCorrecto : char list -> bool = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let esSudokuCorrecto lstTablero = sonlasFilaCorrectas (1, lstTablero) \&\&
sonlasColumnasCorrectas (1, lstTablero) \&\& sonlosCuadradosCorrectos (1,
lstTablero);;
\end{verbatim}

\section{Lógica para Resolver el Sudoku de manera F\'acil}

\subsection{quitarElemento}

\paragraph{Propósito:} Función que elimina un elemento de una lista dada.
\paragraph{Prototipo:} quitarElemento : 'a * 'a list -> 'a list -> 'a list = <fun>
\paragraph{Prueba 1:} quitarElemento(10,[]) (listaFila 5);;
\paragraph{Código:}
\begin{verbatim}
let rec quitarElemento (elemento, cabezaLista) = function [] -> []
			 |h::f-> if (elemento = h) then cabezaLista@f
				 else
			quitarElemento (elemento, cabezaLista@[h]) f;;
\end{verbatim}

\subsection{elementosListadeEnteros}

\paragraph{Propósito:} Función que extrae una lista genérica para lista de enteros dada.
\paragraph{Prototipo:} elementosListadeEnteros : 'a list * 'a list -> int list -> 'a list =
<fun>
\paragraph{Prueba 1:} elementosListadeEnteros ([],(lstTablero tablero1)) (listaFila 5);;
\paragraph{Código:}
\begin{verbatim}
let rec elementosListadeEnteros (listaFinal,tablero) = function [] -> listaFinal
			| h::f ->
elementosListadeEnteros ((listaFinal@[(elemento(h, 1, tablero))]),tablero) f;;
\end{verbatim}

\subsection{elementosFila}

\paragraph{Propósito:} Es el "front" para obtener la lista genérica de elementos de una fila
a partir de un índice.
\paragraph{Prototipo:} elementosFila : int * 'a list -> 'a list = <fun> 
\paragraph{Prueba 1:}elementosFila (5, (lstTablero tablero1));;
\paragraph{Código:}
\begin{verbatim}
let elementosFila (elemento,tablero) = elementosListadeEnteros ([], tablero)
(listaFila elemento);;
\end{verbatim}

\subsection{elementosColumna}

\paragraph{Propósito:} Es el "front" para obtener la lista genérica de elementos de una
columna a partir de un índice.
\paragraph{Prototipo:} elementosColumna : int * 'a list -> 'a list = <fun>
\paragraph{Prueba 1:} elementosColumna (5, (lstTablero tablero1));;
\paragraph{Código:}
\begin{verbatim}
let elementosColumna (elemento,tablero) = elementosListadeEnteros ([], tablero)
(listaColumna elemento);;
\end{verbatim}

\subsection{elementosCuadrado}

\paragraph{Propósito:} Es el "front" para obtener la lista genérica de elementos de un
cuadrado a partir de un índice.
\paragraph{Prototipo:} elementosCuadrado : int * 'a list -> 'a list = <fun>
\paragraph{Prueba 1:}elementosCuadrado (5, (lstTablero tablero1));;
\paragraph{Código:}
\begin{verbatim}
let elementosCuadrado (elemento,tablero) = elementosListadeEnteros ([], tablero)
(listaCuadrado elemento);;

\end{verbatim}

\subsection{filasinElemento ???}

\paragraph{Propósito:} Función que elimina de una lista el elemeto dado como parámentro.
\paragraph{Prototipo:} filasinElemento : int * int list -> int list = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
let filasinElemento (elemento, tablero) = quitarElemento (elemento,[])
(elementosFila(elemento, tablero));;
\end{verbatim}

\subsection{elementosparaIndice}

\paragraph{Propósito:} Función que obtiene la lista de elementos para un índice dado.
\paragraph{Prototipo:} elementosparaIndice : int * 'a list -> 'a list = <fun>
\paragraph{Prueba 1:} elementosparaIndice (5, (lstTablero tablero1));;
\paragraph{Código:}
\begin{verbatim}
let elementosparaIndice (elemento, tablero) = (elementosFila
(elemento,tablero))@(elementosColumna (elemento,tablero))@(elementosCuadrado
(elemento,tablero));;
\end{verbatim}

\subsection{eliminarBlancos}

\paragraph{Propósito:} Función que elimina el carácter `.` de una lista dada.
\paragraph{Prototipo:} eliminarBlancos : char list -> char list -> char list = <fun>
\paragraph{Prueba 1:} eliminarBlancos ([]) (elementosparaIndice (5, (lstTablero
tablero1)));;
\paragraph{Código:}
\begin{verbatim}
let rec eliminarBlancos (listaLimpia) = function [] -> listaLimpia
		|h::f -> if (h = `.`) then eliminarBlancos (listaLimpia) f
			 else eliminarBlancos (listaLimpia@[h]) f;;
\end{verbatim}

\subsection{insertar}

\paragraph{Autor:} Luis Bengochea Martínez.
\paragraph{Licencia de Código:} (C) Luis Bengochea Martínez. Departamento de Ciencias de la
Computación. Universidad de Alcalá (UAH). Todos los derechos reservados.
\paragraph{Propósito:} Función que inserta un elemento en una lista.
\paragraph{Prototipo:} insertar : 'a -> 'a list -> 'a list = <fun>
\paragraph{Código:}
\begin{verbatim}
let rec insertar n = function [] -> [n]
                           |x::l -> if x=n then x::l
                                    else if x>n then n::x::l
                                    else x::(insertar n l);;
\end{verbatim}

\subsection{ordenar}

\paragraph{Autor:} Luis Bengochea Martínez.
\paragraph{Licencia de Código:} (C) Luis Bengochea Martínez. Departamento de Ciencias de la
Computación. Universidad de Alcalá (UAH). Todos los derechos reservados.
\paragraph{Propósito:} Función que ordena una lista genérica de elementos.
\paragraph{Prototipo:} ordenar : 'a list -> 'a list = <fun>
\paragraph{Prueba 1:} ordenar (eliminarBlancos ([]) (elementosparaIndice (5, (lstTablero
tablero1))));; 
\paragraph{Prueba 2:} ordenar [`5`;`1`;`B`;`A`;`3`;`7`;`1`];;
\paragraph{Código:}

\begin{verbatim}
let rec ordenar = function [] -> []
                       | x::l -> insertar x (ordenar l);;
\end{verbatim}

\subsection{buscarElemento}

\paragraph{Propósito:} Función que busca partiendo en una lista el elemento que no se
encuentra en la otra.
\paragraph{Prototipo:} buscarElemento : 'a list -> 'a list -> 'a = <fun>
\paragraph{Prueba 1:} buscarElemento [`0`;`1`;`2`;`3`;`4`;`5`;`6`;`7`;`8`;`9`;`A`;`B`;`.`]
(ordenar (eliminarBlancos ([]) (elementosparaIndice (5, (lstTablero
tablero1)))));;
\paragraph{Código:}
\begin{verbatim}
let rec buscarElemento listaFormal = function [] -> hd(listaFormal)
	|h::f -> if (h = hd(listaFormal)) then buscarElemento (tl(listaFormal)) f 
		 else hd(listaFormal);;
\end{verbatim}

\subsection{}

\paragraph{Propósito:} Se trata de un "front" para "buscarElemento", con el objetivo de
simplificar el código.
\paragraph{Prototipo:} frontBuscarElemento : int -> char list -> char = <fun> 
\paragraph{Prueba 1:} frontBuscarElemento 5 (lstTablero tablero1);;
\paragraph{Código:}
\begin{verbatim}
let rec frontBuscarElemento indice tablero = buscarElemento
[`0`;`1`;`2`;`3`;`4`;`5`;`6`;`7`;`8`;`9`;`A`;`B`;`.`] (ordenar (eliminarBlancos
([]) (elementosparaIndice (indice, tablero))));;
\end{verbatim}

\subsection{}

\paragraph{Propósito:} Función que devuelve un elemento para un índice dado.
\paragraph{Prototipo:} elementoparaIndice : int -> int -> 'a list -> 'a = <fun>
\paragraph{Prueba 1:} elementoparaIndice 1 5 (lstTablero tablero1);;
\paragraph{Código:}
\begin{verbatim}
let rec elementoparaIndice indiceRecorrido indiceInicial lista = 
   if (indiceInicial = indiceRecorrido) then (hd(lista))
   else elementoparaIndice(indiceRecorrido+1) indiceInicial (tl(lista));;
\end{verbatim}

(*
???
Propósito:
Prototipo:
*)




(*
Prueba 1:
*)

\subsection{}

\paragraph{Propósito:}
\paragraph{Prototipo:}
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}

\end{verbatim}

(*
Propósito: Función que inserta en un tablero una jugada y reconstruye el mismo.
Prototipo: fontTableroconJugada : int * string * string -> string = <fun>
*)

let fontTableroconJugada (indice, jugada, strTablero) = (concat
[(substrPreAccion (strTablero, (fila indice), (columna
indice)));jugada;(substrPostAccion (strTablero, (fila indice), (columna
indice)))]);;

\subsection{}

\paragraph{Propósito:}
\paragraph{Prototipo:}
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}

\end{verbatim}

(*
Propósito: Función que resuelve el Sudoku por eliminación simple de
posibilidades.
Prototipo: resolverSudokudeManeraFacil : int * string * string -> string = <fun>
*) 

let rec resolverSudokudeManeraFacil (indice, strTableroFinal, strTableroInicial)
= if (indice > 144) then strTableroFinal
                                                                                
  else if ((elementoparaIndice 1 indice (cadenahaciaListadeChar
strTableroInicial)) = `.`) then let jugada = (frontBuscarElemento indice
(cadenahaciaListadeChar strTableroInicial)) in resolverSudokudeManeraFacil
((indice+1), strTableroFinal\^(char\_for\_read jugada),(fontTableroconJugada
(indice, (char\_for\_read jugada), strTableroInicial)))
                                                                                
  else resolverSudokudeManeraFacil ((indice+1),
strTableroFinal\^(char\_for\_read(elementoparaIndice 1 indice
(cadenahaciaListadeChar strTableroInicial))),strTableroInicial);;

(*
Tableros de Prueba: Original:
"6193B07A24850AB43528967175281694A03B8B47610235A99610A45382B7235A78B96104B4390A6
517281765928B034AA80243175B9649A15730B862508B29467A1332768BA14950"

let tableroPruebaFacil1 =
"6193.07A24850AB43528967175281694A03B8B47610235A99610A45382B7235A78B96104B4390A6
517281765928B034AA80243175B9649A15730B862508B29467A1332768BA1....";;
let tableroPruebaFacil2 =
".193B07A2485.AB435289671.5281694A03B.B47610235A99610A45382B7235A78B96104B4390A6
517281765928B034AA80243175B9649A15730B862508B29467A1332768BA14950";;

Prueba 1: 

resolverSudokudeManeraFacil (1, "", tableroPruebaFacil1);;

Prueba 2: 

resolverSudokudeManeraFacil (1, "", tableroPruebaFacil2);;

*)

\section{Lógica para Resolver el Sudoku de Manera D\'ificil (Algoritmo de
BACKTRAKING}

\section{Función Principal}

\subsection{main}

\paragraph{Propósito:} Tratar todo el conjunto de "sub-funciones", para hacer "jugable" el
Sudoku.
\paragraph{Prototipo:} main : char list * string -> unit = <fun>
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}

let rec main (lstTablero, strTablero) =   begin
        imprimirTablero lstTablero;
	print\_string "Estado del Juego: ";
	if(sonlasFilaCorrectas (1,lstTablero) \&\& sonlasColumnasCorrectas (1, lstTablero) \&\&
sonlosCuadradosCorrectos (1, lstTablero)) = true then print\_string "Correcto"
		else print\_string "Incorrecto";
		print\_newline();
		print\_string "1. Jugar";
		print\_newline();
                print\_string "2. Resolver de manera fácil";
		print\_newline();
		print\_string "3. Resolver de manera difícil";
		print\_newline();
		print\_string "4. Salir";
		print\_newline();
                print\_string "Por favor selecciona una opcion: ";
                   let opcion = read\_int () in  
		   if (opcion = 1) then begin
		   let tableroAux =
introJugada (strTablero,0,0,0,1) in main((cadenahaciaListadeChar tableroAux),
tableroAux);
				        end
		    else if (opcion = 2) then begin
let tableroFacil = resolverSudokudeManeraFacil (1, "", strTablero) in
main(cadenahaciaListadeChar(tableroFacil), tableroFacil)
				              end
 		    else if (opcion = 3) then begin
		    ()
				              end
		    else if (opcion = 4) then 
                    ()
				          end;; 
\end{verbatim}

\section{Función de Ejecución}

\subsection{main(cadenahaciaListadeChar(tablero), tablero);; }

\paragraph{Propósito:} Ejecutar el Sudoku.
\paragraph{Prototipo:}
\paragraph{Prueba 1:}
\paragraph{Código:}
\begin{verbatim}
(*
main(cadenahaciaListadeChar(tablero1), tablero1);; 

main(cadenahaciaListadeChar(tablero2), tablero2);; 

main(cadenahaciaListadeChar(tablero3), tablero3);; 

main(cadenahaciaListadeChar(tablero4), tablero4);; 
*)
\end{verbatim}
