\chapter{An\'alisis de Alto Nivel}

\section{\textquestiondown C\'omo hemos desarrollado la Aplicaci\'on?}

\section{Requisitos}
La apliaci\'on Ciudad Deportiva del Laboratorio de Programaci\'on Avanzada para
el curso 2010/2011 en las disciplinas de Ingenier\'ias T\'ecnicas en
Inform\'atica propuso las siguientes restricciones que debe cumplir la
aplicaci\'on. A continuaci\'on las enumeramos:

\subsection{Respecto al funcionamiento general de la aplicaci\'on}

\begin{itemize}
\item El n\'umero total de Hilos que se ejecutan es de 49, cada uno de ellos
identificado entre los n\'umero 51 y 99. Los que tienen n\'umero de
identificaci\'on par son Hilos que corresponden a deportistas masculinos, por
contra, los impares, corresponden a deportistas femeninos. 

Cada deportista se ir\'a creando cada 0,1 segundos. 

\item En el complejo aplicaci\'on Ciudad Deportiva hay cuatro instalaciones:
PistaTenis, SalaMusculacion, CampoGolf y Piscina.

\item El funcionamiento de la PistaTenis tiene las siguientes restricciones:

\begin{itemize}
\item S\'olo puede haber jugando dos deportistas del mismo sexo. 

\item Si la pista est\'a vac\'ia, entra la primera persona que llegue a la
instalaci\'on y espera dentro del complejo a que llegue otra de su mismo sexo
para empezar a jugar.

\item El partido dura entre 0,5 y 1 segundo.

\item Mientras se est\'a jugando todos los deportistas que quieran jugar
esperar\'an en la cola su turno por orden de llegada. 
\end{itemize}

\item La instalaci\'on SalaMusculaci\'on hay 15 aparatos, 9 de ellos para
hombres y 6 de ellos para mujeres. Una vez alcanzado el m\'aximo de su capacidad
los deportistas de ambos sexos tendr\'an que esperar en una cola \'unica su
turno. Cada deportista estar\'a en el aparato entre 0,8 y 1,5 segundos. Cuando
termina deja sitio a otro.

\item La instalaci\'on CampoGolf consta de cuatro hoyos que se juegan de manera
individual. Si un deportistas encuentra en hoyo n\'umero uno vac\'io empieza a
jugar por hoyo entre 0,4 y 0,6 segundos estando el resto de deportistas que
solicitan en la cola hasta que quede de nuevo el hoyo uno vac\'io y comience a
jugar otro Hilo. No pueden jugar, repetimos dos deportistas el mismo hoyo, por
lo que si termina su ciclo y el siguiente est\'a ocupado tendr\'a que esperar.

\item La instalaci\'on Piscina es la primera que visitan los deportistas
durante 5 segundos, d\'onde no hay limitaciones de capacidad.

\item Cada deportista deber\'a usar todas las instalaciones una vez antes de
terminar su vida \'util en la aplicaci\'on.

\item Al terminar el deportistas imprimir\'a un mensaje en consola indicando que
ha terminado y su identificador.

\end{itemize}

\subsection{Respecto al M\'odulo de Control}

La apliaci\'on tendr\'a un m\'odulo de control que se conectar\'a al servidor
(CiudadDeportiva) por la tecnolog\'ia RMI. Tendr\'a las siguientes
restricciones:

\begin{itemize}
 \item Se implementar\'a un m\'etodo jugandoTenis que permita visualizar cuales
jugadores est\'an disputando en ese momento la partida de Tenis.

\item Tendr\'a igualmente un m\'etodo colaMusculacion que nos devolver\'a la
lista de deportistas que est\'an esperando en la cola de la SalaMusculacion.

\item Implementar\'a el m\'etodo cerrarSalaMusuclacion que har\'a el cierre de
la propia sala, con ello, haciendo que los hilos que se encuentran todav\'ia en
ella terminen su ciclo y el resto que intenta acceder espere en la cola hasta
que se abr\'a de nuevo.

\item Contendr\'a el m\'etdo abrirSalaMusculacion para reanudad la actividad
de la SalaMusculacion.

\item El m\'odulo de Control podr\'a ejecutarse desde una computadora diferente
a la que se ejecuta el servidor. Ofercer\'a una interfaz gr\'afica con campos de
texto y botones adem\'as de tres botones para operar con la SalaMusculacion
adem\'as de actualizar los datos (refrescarDatos).
\end{itemize}

\section{Respecto a la propia implementaci\'on}

\subsection{Tecnolog\'ia empleada}

Para dise\~{n}ar el simulador se ha utilizado el Lenguaje de Programaci\'on
Java. Concretamente sus tecnolog\'ia en concurrencia y RMI. A continuaci\'on
haremos un peque\~{n}o resumen descriptivo y bastante te\'orico sobre las
mismas:

\subsubsection{Concurrencia}

\textit{``Los Hilos de ejecuci\'on de procesos son sin lugar a duda
un hito en
la computaci\'on, la posibilidad de compartir un espacio de direcciones en
com\'un, de proceso, y a la vez, ser unidades funcionales independientes dota a
los sistemas distribuidos de gran versatilidad a la par de complejidad en el
dise\~{n}o, ya que como hemos dicho (repetimos), el hilo comparte, el espacio de
memoria con otros hilos, asignados al proceso...''} \cite{tsoddlp}.

\defn Hacemos un distinci\'on entre Hilo y Tarea. Un hilo puede se un conjunto
de uno o varios Tareas. Puede ser con esto dise\~{n}ado para una \'unica
funci\'on o desempe\~{n}ar varias a los largo de su vida \'utilo de ejecuci\'on.

\defn Para crear un Hilo en Java se necesita o bien de implementar la interfaz
Runnable o bien extender la clase Thread.

{\cor La ventaja de utilizar la interfaz Runnable radica en su flexibilidad en
la implementaci\'on del propio Hilo.}


{\cor Java dota al programador de una serie de \'utiles (m\'etodos) para
controlar el estado del Hilo.}

\subsubsection{Comunicaci\'on entre Hilos}

\defn En un entorno de m\'ultiples Hilos se emplean unas t\'ecnicas
espec\'ificas
para la comunicaci\'on.

{\cor Un ejemplo de estas son el algoritmo Productor/Consumidor.}

{\cor El repertorio del que dota Java al programador para el control del estado
se basa en:}

\begin{equation}
\Sigma = \{wait(), notify()\}
\end{equation}

{\cor Esta t\'ecnica consta de tres elementos principales \cite{j2muafq}:

\begin{itemize}
\item Productor: Generador de los elementos a controlar.

\item Consumidor: Reductor de los elementos a controlar.

\item Monitor: Control de los elementos desde el Productor hasta el Consumidor.
\end{itemize}

}
\subsubsection{RMI}

\defn La tecnolog\'ia RMI de Java permite comunicar objetos de manera
distribuida, es decir, estos se pueden ejecutar en m\'aquinas distintas.

{\cor Se basa en una arquitectura de Cliente/Servidor.}

{\cor Para ello en necesario un registrador de objetos.}

{\cor La serializaci\'on es una t\'ecnica que permite que los objetos pueden ser
intercambiados entre equipos sin perder la consistencia de los mismos.}


\section{Elementos principales}

\section{La implementaci\'on de la L\'ogica Concurrente}

A continuaci\'on haremos un desglose textual de la implementaci\'on que contiene
cada una de las clases resaltando el c\'odigo eje motor de la clase.

\subsection{Clase PlantillaDeportista.java}

\subsubsection{Representaci\'on UML}

\begin{center}
 \includegraphics{./uml/PlantillaDeportista.1}
 % PlantillaDeportista.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

\subsubsection{Comentario}

\begin{verbatim}
import java.io.*;

public class PlantillaDeportista implements Serializable {

    private int identificador;

    PlantillaDeportista(int pIdentificador) {

        identificador = pIdentificador;
    }

    public int getIdentificador() {
        return identificador;
    }

    public void setIdentificador(int pIdentificador) {
        identificador = pIdentificador;
    }
}
\end{verbatim}

Se trata la abstracci\'on de un deportista. \'Unicamente nos interesa la
variable identificador y su m\'etodos de acceso. Esta, implementa la
serializaci\'on ya que un conjunto de ellos ser\'an transmitidos por RMI. 

\subsection{Clase Deportista.java}


\subsubsection{Representaci\'on UML}

\begin{center}
 \includegraphics{./uml/Deportista.1}
 % PlantillaDeportista.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

\subsubsection{Comentario}

Se trata de un Hilo ya que deriva de la clase \textit{Thread}.

Contiene las siguientes variables de sincronizaci\'on:

\begin{verbatim}
private int varIdentificador;

private boolean estadoDetenido;
\end{verbatim}

Que dan la funcionalidad, en el caso de identificador de contener el \'indice
del Hilo. Y en el caso de estadoDetenido, se hace necesario para detener nuestro
Hilos como monitor, como veremos en el m\'etodo \textit{pararEjecuci\'on()}.

El control de estado se hace para activar\footnote{Dicho m\'etodo es ejecutado
por el bot\'on de REANUDAR Hilos.}, por medio de:

\begin{verbatim}
public synchronized void reanudar() {
        estadoDetenido = false;
        notify();
    }
\end{verbatim}


y para detener por medio de:

\begin{verbatim}
    public void pararEjecucion() {
        try {
            synchronized (this) {
                while (estadoDetenido == true) {
                    wait();
                }
            }
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }
    }

\end{verbatim}

Ambos m\'etodos acceden a la variable booleana \textit{estadoDetenido}. Lo hacen
de manera sincronizada y emplean, en el caso de ser activado el control de
\textit{notify()} para monito y \textit{wait()} para detener.

El m\'etodo \textit{run()} implementa un monitor para cada una de las
instalaciones. Comienza creando un nuevo Hilo-Deportista:

\begin{verbatim}
PlantillaDeportista varPDeportista = new PlantillaDeportista(varIdentificador);
\end{verbatim}

Para depu\'es hacer que este haga la instalaci\'on piscina y mediante un
\textit{switch} y hasta que no haya pasado por todas y cada una de las
instalaciones (cada elemento del switch con el monitor correspondiente), no
termine:

\begin{verbatim}
//Finaliza el Hilo
        CiudadDeportiva.JTextFinal.setText("<" +
String.valueOf(varIdentificador) + ">");
        System.out.println("Finaliza el Deportista con identificador: " +
varIdentificador);
\end{verbatim}

\paragraph{Nota:} De modo gen\'erico cada monitor se encarga de que
secuencialmente haga cada una de las actividades con sus etapas controlando el
flujo con Thread con pararEjecucion() en el monitor principal. Siendo el monitor
de cada aplicaci\'on el que reanude su actividad. 



\subsection{Clase Piscina.java}

Contiene un \textit{ArrayList}:

\begin{verbatim}
private ArrayList<PlantillaDeportista> varPiscina;
\end{verbatim}

d\'onde se almacenan los deportistas y, los siguientes m\'etodos:

\begin{verbatim}
public synchronized String imprimirPiscina() {
//EL CODIGO SE ENCARGA DE MOSTRAR LOS DEPORTISTAS EN LA INSTALACION
}

//MONITOR PISCINA
public synchronized void monitorPiscina(PlantillaDeportista pDeportista) {
   varPiscina.add(pDeportista);
}

//PRODUCTOR PISCINA
public synchronized void productorPiscina(PlantillaDeportista pDeportista) {
   varPiscina.remove(pDeportista);
}
\end{verbatim}

El CONSUMIDOR est\'a implementado de manera l\'ogica en el \textit{switch} antes
citado de la clase Deportista.


\subsection{Clase CampoGolf.java}

Contiene las siguiente variables:

\begin{verbatim}
//Variables de sincronizacion para exclusion mutua
private boolean llenoHoyo1;
private boolean llenoHoyo2;
private boolean llenoHoyo3;
private boolean llenoHoyo4;
//Almacenes para cada hoyo
private ArrayList<PlantillaDeportista> deportistaHoyo1;
private ArrayList<PlantillaDeportista> deportistaHoyo2;
private ArrayList<PlantillaDeportista> deportistaHoyo3;
private ArrayList<PlantillaDeportista> deportistaHoyo4;
//Alamacen para intalacion
private ArrayList<PlantillaDeportista> colaCiudadDeportiva;
//Numero total de deportistas por hoyo
private int numMaximoDeportistas = 1;
\end{verbatim}

d\'onde:

\begin{itemize}
\item $llenoHoyo\lambda \Longrightarrow$ una variable candado para cada Hoyo.
\item $deportistaHoyo\lambda \Longrightarrow$ un ArrayList por cada Hoyo que
continen a los deportistas.
\item $colaCiudadDeportiva\lambda \Longrightarrow$ un ArrayList con los
deposrtistas en espera.
\item $numMaximoDeportistas \Longrightarrow$ el n\'umero m\'aximo de deportistas
por Hoyo\footnote{Esto est\'a directamente implicado con el tama\~{n}o de
$deportistaHoyo\lambda$.}.
\end{itemize}


Hay un m\'etodo ``cerrojo'' por cada Hoyo, $estaLlenoHoyo\lambda$(). Y un
conjunto de m\'etodos para controlar la ``salida por pantalla''. 


Por otra parte hay un CONSUMIDOR por cada Hoyo (Mostramos para el Hoyo 1):

\begin{verbatim}
public synchronized void consumidorHoyo1(PlantillaDeportista
pPlantillaDeportista) {
        //Añade por defecto para espera
        colaCiudadDeportiva.add(pPlantillaDeportista);
       
CiudadDeportiva.JTextColaCampodeGolf.setText(imprimirColadeCampodeGolf());

        while (estaLlenoHoyo1() == true) {
            try {
                //Espera
                wait();
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
        //Activa
        notifyAll();

        //Inserta deportista en el hoyo
        colaCiudadDeportiva.remove(pPlantillaDeportista);
        deportistaHoyo1.add(pPlantillaDeportista);

        //Muestra texto
       
CiudadDeportiva.JTextColaCampodeGolf.setText(imprimirColadeCampodeGolf());
        CiudadDeportiva.JTextHoyo1.setText(mostrarHoyo1());
        try {
            //Descansa
            sleep((((long) (Math.random() * (200)) + 400)));
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }

    }
\end{verbatim}

Y un productor:

\begin{verbatim}
    public synchronized void productorCampodeGolf(PlantillaDeportista
pPlantillaDeportista) {
        deportistaHoyo4.remove(pPlantillaDeportista);
        CiudadDeportiva.JTextHoyo4.setText(mostrarHoyo4());
        notifyAll();
    }
\end{verbatim}

Que devuelve al flujo principal el deportista.



\subsection{Clase SalaMusculacion.java}

El c\'odigo que presenta est\'a clase a nivel estructural se parace mucho a la
antes citada CampoGolf ya que todo nuestro trabajo de concurrencia ha sido
tratado mediante monitores. Por ello tenemos las variables:

\begin{verbatim}
private int DeportistasMas = 9;
private int DeportistasFem = 6;
private boolean llenoMas;
private boolean llenoFem;
private boolean abierto;
private ArrayList<PlantillaDeportista> deportistaInstalacionMas;
private ArrayList<PlantillaDeportista> deportistaInstalacionFem;
private ArrayList<PlantillaDeportista> colaInstalacion;
\end{verbatim}

de ``cerrojo'' y Lista\footnote{La variable \textit{abierto} es empleada para
RMI.} para los deportistas.


Por otra parte tenemos l,os m\'etdos para cada candado y la l\'ogica de RMI:

\begin{verbatim}
public boolean estaAbierto() {
        return abierto;
    }

    /** Método que abre o cierra la Sala de musculacion */
    public synchronized void setAbierto(boolean abierto) {
        if (abierto == true) {
            if ((this.abierto == false) && (deportistaInstalacionMas.size() ==
DeportistasMas) && (deportistaInstalacionMas.size() == DeportistasMas)) {
                System.out.println("Deportistas terminando el ejercicio...");
            } else {
                CiudadDeportiva.jLabelEstadoSala.setText("Estado de la Sala:
Abierta");
                this.abierto = abierto;
                notifyAll();
            }
        } else {
            CiudadDeportiva.jLabelEstadoSala.setText("Estado de la Sala:
Cerrada");
            this.abierto = abierto;
            if (colaInstalacion.size() > 0) {
                llenoMas = false;
                llenoFem = false;
                notifyAll();
            }
        }
    }
\end{verbatim}

M\'as l\'ogica para ``salida de datos''. Y por \'ultimo nuestros CONSUMIDORES
que se diferencian por sexo y son llamados por:

\begin{verbatim}
public synchronized void insertarenMusculacion(PlantillaDeportista
pPlantillaDeportista) {
        if (pPlantillaDeportista.getIdentificador() % 2 == 0) {
            insertarenMusculacionMas(pPlantillaDeportista);
        } else {
            insertarenMusculacionFem(pPlantillaDeportista);
        }
    }
\end{verbatim}

De modo gen\'erico mostramos el consumidor de depostistas masculinos:

\begin{verbatim}
public synchronized void insertarenMusculacionMas(PlantillaDeportista
pPlantillaDeportista) {
        while ((llenoMas == true) || (abierto == false)) {
            try {
                wait();
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
        notify();
        colaInstalacion.remove(pPlantillaDeportista);
        deportistaInstalacionMas.add(pPlantillaDeportista);
        llenoMas = deportistaInstalacionMas.size() == DeportistasMas;
        CiudadDeportiva.JTextColaSaladeMusculacion.setText(mostrarCola());
        CiudadDeportiva.jTextSaladeMusculacion.setText(mostrarInstalacion());
    }
\end{verbatim}

que comprueba los cerrojos, sino est\'an disponibles espera y por \'ultimo
libera recurso.

Y finalmente el productor:

\begin{verbatim}
public synchronized void quitarMusculacion(PlantillaDeportista
pPlantillaDeportista) {

        if (pPlantillaDeportista.getIdentificador() % 2 == 0) {
            deportistaInstalacionMas.remove(pPlantillaDeportista);
            llenoMas = false;
        } else {
            deportistaInstalacionFem.remove(pPlantillaDeportista);
            llenoFem = false;

        }
        CiudadDeportiva.jTextSaladeMusculacion.setText(mostrarInstalacion());
        notify();

    }
\end{verbatim}

que tiene la funci\'on de devolver el deportista al flujo principal.

\subsection{Clase PistaTenis.java}

\subsection{Clase CiudadDeportiva.java}

La clase contiene:

\begin{verbatim}
static ArrayList<Deportista> arrayHilos;
\end{verbatim}

Al que se asocian todos los deportistas (Hilos) para poder ser controlados a
modo de conjunto. 

Es por ello que esta clase incorporta el c\'odigo para la interfaz gr\'afica
(SWING) adem\'as de los botones de paro y reanuar de Hilos:

\begin{verbatim}
  //Bonton para detener procesos
    private void jButtonDetenerActionPerformed(java.awt.event.ActionEvent evt) {
                                              
        for (int cont = 0; cont < 49; cont++) {
            arrayHilos.get(cont).detener();
        }
    }                                              

    //Boton para reanudar procesos
    private void jButtonReanudarActionPerformed(java.awt.event.ActionEvent evt)
{                                                
        for (int cont = 0; cont < 49; cont++) {
            arrayHilos.get(cont).reanudar();
        }
\end{verbatim}

Que como vemos recorren el conjunto de Hilos para ejercer el control, uno por
uno, y:

\begin{verbatim}
 public void run() {
                new CiudadDeportiva().setVisible(true);
                arrayHilos = new ArrayList();
                piscina = new Piscina();
                campodeGolf = new CampoGolf();
                pistadeTenis = new PistaTenis();
                saladeMusculacion = new SalaMusculacion();

                //Iniciamos hilos
                for (int cont = 51; cont <= 99; cont++) {
                    Deportista c = new Deportista(cont);
                    arrayHilos.add(c);
                }
                //Ejecutamos hilos
                for (int cont = 0; cont < 49; cont++) {
                    arrayHilos.get(cont).start();
                }
\end{verbatim}

Para inicializar clases e Hilos como, por \'ultimo, el \textit{Naming.rebind}
para RMI\footnote{En este caso con la direcci\'on, \textit{localhost}.}:

\begin{verbatim}
//Iniciamos el Objeto Remoto en local
                try {
                    CiudadRMI datosCiudad = new CiudadRMI();
                    Naming.rebind("//127.0.0.1/ObjetoRMI", datosCiudad);
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
\end{verbatim}



\section{La implementaci\'on RMI}

\subsection{Interfaz InterfazCiudadRMI.java}

\subsubsection{Representaci\'on UML}

\begin{center}
 \includegraphics{./uml/InterfazCiudadRMI.1}
 % PlantillaDeportista.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

\subsubsection{Comentario}

Dicha interfaz implementa la l\'ogica de prototipado para m\'etdos remotos. Es
en sintesis una abstracci\'on para hacer m\'as gene\'erica nuestra
implementaci\'on:

\begin{verbatim}
public interface InterfazCiudadRMI extends Remote {

    //Prototipos de metodos para RMI
    ArrayList<PlantillaDeportista> estadoColaSaladeMusculacion() throws
RemoteException;

    ArrayList<PlantillaDeportista> estadoPistadeTenis() throws RemoteException;

    void abrirSaladeMusculacion() throws RemoteException;

    void cerrarSaladeMusculacion() throws RemoteException;
}
\end{verbatim}

\subsection{Clase CiudadRMI.java}

\subsubsection{Representaci\'on UML}

\begin{center}
\includegraphics{./uml/CiudadRMI.1}
 % PlantillaDeportista.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

\subsubsection{Comentario}

Implementa la interfaz antes citada y llama por cada m\'etodo a la acci\'on
dentro del c\'odigo de servidor, la ejecuci\'on del programa para ser enviada
como flujo de bits.

\begin{verbatim}
public class CiudadRMI extends UnicastRemoteObject implements InterfazCiudadRMI
{

    //Constructor
    public CiudadRMI() throws RemoteException {
    }

    //Implementacion de metodos para RMI
    public ArrayList<PlantillaDeportista> estadoColaSaladeMusculacion() throws
RemoteException {
        return CiudadDeportiva.saladeMusculacion.getColaInstalacion();
    }

    public ArrayList<PlantillaDeportista> estadoPistadeTenis() throws
RemoteException {
        return CiudadDeportiva.pistadeTenis.getDeportistaInstalacion();
    }

    public void abrirSaladeMusculacion() throws RemoteException {
        CiudadDeportiva.saladeMusculacion.setAbierto(true);

    }

    public void cerrarSaladeMusculacion() throws RemoteException {
        CiudadDeportiva.saladeMusculacion.setAbierto(false);
    }
}
\end{verbatim}

\subsection{Clase ModuloControl.java}

\subsubsection{Representaci\'on UML}

\begin{center}
\includegraphics{./uml/ModuloControl.1}
 % PlantillaDeportista.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

\subsubsection{Comentario}

Contiene tres botones y su l\'ogica para RMI: Abrir Sala de Musculaci\'on,
Cerrar Sala de Musculaci\'on y Refrescar con sus correspondientes TextBox.

Por otra parte en el m\'etodo principal (main) se hace la llamada al objeto
remoto:

\begin{verbatim}
datosCiudad=(InterfazCiudadRMI)Naming.lookup("//127.0.0.1/ObjetoRMI");
\end{verbatim}

para ser empleado en cada uno de los botones del m\'odulo, como hemos dicho:

\begin{verbatim}
private void
jButtonAbrirSaladeMusculacionActionPerformed(java.awt.event.ActionEvent evt) {  
                                                           
        try {
            datosCiudad.abrirSaladeMusculacion();
        } catch (RemoteException e) {
            System.out.println(e.getMessage());
        }
    }                                                             

    private void jButtonActualizarActionPerformed(java.awt.event.ActionEvent
evt) {                                                  
        //Recibe el estado de la cola de musculacion y de la pista de tenis y
muestra todo por pantalla
        try {
            ArrayList<PlantillaDeportista> cola =
datosCiudad.estadoColaSaladeMusculacion();
            ArrayList<PlantillaDeportista> local =
datosCiudad.estadoPistadeTenis();
            String muestra = "";


            for (int cont = 0; cont
                    < cola.size(); cont++) {
                muestra = muestra + "Identificador: " +
String.valueOf(cola.get(cont).getIdentificador());
            }
            jTextSaladeMusculacion.setText(muestra);
            muestra =
                    "";


            for (int cont = 0; cont
                    < local.size(); cont++) {
                muestra = muestra + "Identificador: " +
String.valueOf(local.get(cont).getIdentificador());
            }
            jTextTenis.setText(muestra);


        } catch (RemoteException e) {
            System.out.println(e.getMessage());
        }

    }                                                 

    private void
jButtonCerrarSaladeMusculacionActionPerformed(java.awt.event.ActionEvent evt) { 
                                                             
        try {
            datosCiudad.cerrarSaladeMusculacion();


        } catch (RemoteException e) {
            System.out.println(e.getMessage());
        }
    }                                          
    }
\end{verbatim}

\section{An\'alisis UML}
%\includegraphics{./uml/CampoGolf.1}
 % CampoGolf.1: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=


